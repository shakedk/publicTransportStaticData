<!--Version 1-->
<!--This version includes the following mapping:

Map is a leaflet map with mapbox tiles.
Lines are drawn using leaflet API (hence it's styling)
Station are mapped to d3 changeStations.

line path is mapped to shape. Each line mapped to differrent color
Every relevant station (i.e. station where two lines intersect) is mapped to a circle with a text.
The best station to switch stations at has double mappings:
1. The better the station (=the shorter time), the bigger the station's icon.
 The waiting time is mapped to the circle's radius ([Max time - current time]), the bigger the better.
2. The better the station, the darker is the station's hue.

The waiting time is mapped to the circle's hue and indicated in a hover tooltip.

Coloring: the lines and the circle are 3 distinctive colors (red, blue and green). The station's colors received sequntial scaling.

Next iterations: suggestions:
- Cancel double mapping: map stations to icons and shortest waiting time to darkest hue.
- Add a legend for the waiting times
- Add a tooltip for the line
- Add origin & destination stations indication

-->
<!DOCTYPE html>
<html>
<!--import thr leaflet css-->
<link
        rel="stylesheet"
        href="http://cdn.leafletjs.com/leaflet-0.7/leaflet.css"
        />

<head>
    <!--Script imports-->
    <meta charset="utf-8"/>
    <link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet-0.7/leaflet.css"/>
    <script src="http://d3js.org/d3.v3.min.js" type="text/javascript"></script>
    <script src="http://cdn.leafletjs.com/leaflet-0.7/leaflet.js"></script>
    <script src='https://api.tiles.mapbox.com/mapbox.js/v1.6.4/mapbox.js'></script>
    <link href='https://api.tiles.mapbox.com/mapbox.js/v1.6.4/mapbox.css' rel='stylesheet'/>
    <!--General Styling-->
    <style>
        html,
        body {
            height: 100%;
            width: 100%;
            margin: 0;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        svg {
            position: relative;
        }

        path {
            fill-opacity: 0;
            stroke-width: 7px;
            stroke-opacity: 0.5;
        }

        .stationsText {
            stroke: black;
            stroke-width: 0.1px;
            fill: #67000d;
            font-size: 10pt;
            font-weight: bold;
        }

        .stations {
            stroke-width: 1px;
            stroke: black;
        }

        .lineStations {
            fill-opacity: 0;
            stroke-opacity: 0;;
        }

        .legend {
            padding: 6px 8px;
            font: 14px/16px Arial, Helvetica, sans-serif;
            background: white;
            background: rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
            border-radius: 5px;
            line-height: 18px;
            color: #555;
        }

    </style>

</head>

<body>

<div id="map">
    <script type="text/javascript">

        //Importing the mapbox tiles layer. For our purposes, the example map is sufficient
        var mapboxTiles = L.tileLayer('https://{s}.tiles.mapbox.com/v3/examples.map-zr0njcqy/{z}/{x}/{y}.png', {
            attribution: '<a href="http://www.mapbox.com/about/maps/" target="_blank">Terms &amp; Feedback</a>'
        });

        //Importing the map from leaflet and adding the tiles layer.
        //The initial view is centered to Tel Aviv, according to the example info (lines 171 and 222).
        var map = L.map('map')
                .addLayer(mapboxTiles)
                .setView([32.07452, 34.78875], 13);

        // Initialize the SVG layer
        map._initPathRoot()


        // Categorical colors for 2 lines routes and the optional changing station's colors
        // 3 color hues were chosen using ColorBrewer
        var mappingColors =
        {
            "line1Color": "rgb(152,78,163)",
            "line2Color": "rgb(255,127,0)"
        };

        // Third color, to be sequential and used to dsitinguish between the best and worst change stations
        var greens = ['rgb(247,252,245)', 'rgb(229,245,224)', 'rgb(199,233,192)', 'rgb(161,217,155)', 'rgb(116,196,118)', 'rgb(65,171,93)', 'rgb(35,139,69)', 'rgb(0,90,50)'];

        //Holds the hues that will be assigned for the waiting time mapping (the station changeStations color).
        //The actual setting is done after the relevant number of optional changing station is calculated.
        var stationsHues;

        // We pick up the SVG from the map object
        var svg = d3.select(map.getPanes().overlayPane).append("svg"),
                g = svg.append("g").attr("class", "leaflet-zoom-hide");

        //Styling variables used for the routes path layer
        var Style501 = {
            "color": mappingColors.line2Color
        };

        var Style171 = {
            "color": mappingColors.line1Color
        };

        //Drawing the routes' paths using leaflet layer and not svg
        d3.json("stopShapes61551_501.geojson", function (collection) {

            L.geoJson(collection, {style: Style501}).addTo(map);
        });

        d3.json("stopShapes52473_171.geojson", function (collection) {
            L.geoJson(collection, {style: Style171}).addTo(map);
        });

        //Adding a legend with sequential horizontal bar for easy access
        var legend = L.control({position: 'bottomright'});

        legend.onAdd = function (map) {

            var div = L.DomUtil.create('div', 'legend');
            div.innerHTML += '<p style="margin:auto; background: linear-gradient(to right, ' + greens + ')"</p>' + '<br>';
            div.innerHTML += '<p style="font-weight: bold"> longest waiting &#8596 shortest waiting</p>';
            return div;
        };

        legend.addTo(map);

        //Using SVG, iterating the stations and displaying only the
        //change stations (in this example there are only 8 stations)
        d3.json("stopTimesBothLines501_171.geojson", function (geoShape) {

            //  create a d3.geo.path to convert GeoJSON to SVG
            var transform = d3.geo.transform({point: projectPoint}),
                    path = d3.geo.path().projection(transform);


            // create path elements for each of the features
            stations = g.selectAll("path")
                    .data(geoShape.features)
                    .enter().append("path")
                    .data(geoShape.features)
                    .attr("class", "lineStations")

            //Add circles for the change stations, filtered by having a  waiting time ranking
            changeStations = g.selectAll("circle")
                    .data(geoShape.features
                            .filter(function (d) {
                                return (d.properties.WAIT_RANK != undefined)
                            }))
                    .enter()
                    .append("svg:circle")

            // Add ellipses for indicating the origin and destination stations specified by the user
            origDestStations = g.selectAll("ellipse")
                    .data(geoShape.features
                            .filter(function (d) {
                                return (d.properties.IS_ORIGIN == "TRUE" || d.properties.IS_DEST == "TRUE")
                            }))
                    .enter()
                    .append("svg:ellipse")

            //Adding text for each of the origin, destination and change stations
            stationName = g.selectAll("text")
                    .data(geoShape.features
                            .filter(function (d) {
                                return (d.properties.WAIT_RANK != undefined ||
                                d.properties.IS_ORIGIN == "TRUE" || d.properties.IS_DEST == "TRUE")
                            }))
                    .enter()
                    .append("svg:text")
                    .attr("dx", "12")
                    .attr("dy", "4")
                    .text(function (d) {
                        var stopName = d.properties.STOP_NAME;
                        if (d.properties.IS_ORIGIN == "TRUE")
                            stopName = "מוצא: " + stopName;
                        if (d.properties.IS_DEST == "TRUE")
                            stopName = "יעד: " + stopName;
                        return stopName;
                    })
                    .attr("class", "stationsText")

            //Calculating the minimum and maximum waiting ranks for the color scaling domain
            minVal = d3.min(geoShape.features, function (d) {
                if (d != undefined)
                    return d.properties.WAIT_RANK;
                return Number.MAX_VALUE;
            });

            maxVal = d3.max(geoShape.features, function (d) {
                if (d.properties.WAIT_RANK != undefined)
                    return d.properties.WAIT_RANK
                else
                    return 0;
            });

            numOfChangeStations = geoShape.features.filter(function (d) {
                return (d.properties.WAIT_RANK != undefined)
            }).length;

            //Scaling the waiting rank to the generated color scale
            stationsHues = d3.scale.quantize()
                    .domain([minVal, maxVal])
                    .range(greens);
            //Alerting the user that only up to 9 change stations will be displayed
            //only if there are more than 9 in the data
            if (numOfChangeStations > 9)
                alert("Showing top 9 stations with shortest change time");

            //setting the map reset function for refreshing the view after zoom & pan
            map.on("viewreset", reset);

            reset();


            function reset() {

                // fit the SVG element to leaflet's map layer
                bounds = path.bounds(geoShape);

                var topLeft = bounds[0],
                        bottomRight = bounds[1];


                svg.attr("width", bottomRight[0] - topLeft[0])
                        .attr("height", bottomRight[1] - topLeft[1])
                        .style("left", topLeft[0] + "px")
                        .style("top", topLeft[1] + "px");

                g.attr("transform", "translate(" + -topLeft[0] + ","
                        + -topLeft[1] + ")");

                // initialize & update the path data
                stations.attr("d", path)
                        .attr("class", "lineStations")
                        .text("Line Number");

                //updating the station names and shapes locations according
                stationName.attr("x", function (d) {
                    return path.centroid(d)[0];
                })
                        .attr("y", function (d) {
                            return path.centroid(d)[1];
                        })


                origDestStations.attr("cx", function (d) {
                    return path.centroid(d)[0];
                })
                        .attr("cy", function (d) {
                            return path.centroid(d)[1];
                        })
                        .attr("rx", 10)
                        .attr("ry", 7)
                        .attr("class", "stations")
                        .style("fill", "#ffff33")
                        .append("svg:title");


                changeStations.attr("cx", function (d) {
                    return path.centroid(d)[0];
                })
                        .attr("cy", function (d) {
                            return path.centroid(d)[1];
                        })
                        .attr("r", 10)
                        .style("fill", function (d) {
                            return stationsHues(maxVal + 1 - d.properties.WAIT_RANK);
                        })
                        .attr("class", "stations")
                        .append("svg:title")
                        .text(function (d) {
                            return "Waiting time: " + (d.properties.WAIT_TIME);
                        });
            }


            // Use Leaflet to implement a D3 geometric transformation.
            function projectPoint(x, y) {
                var point = map.latLngToLayerPoint(new L.LatLng(y, x));
                this.stream.point(point.x, point.y);
            }

            //adding line numbers in tooltip of the lines
            stations.append("svg:title")
                    .text(function (d) {
                        return "Line Number: " + (d.properties.LINE_NUM);
                    });
        })


    </script>
</div>
</body>

</html>
